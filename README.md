# DijkstrasAlgorithm
PURPOSE: The purpose of the Dijkstra’s Algorithm is to create code that, given a graph of nodes, will find the shortest distance between the given node and all of the existing nodes, and return a list that holds the previous Node (the path to travel) for each distance. The code I created fulfills these specifications to the best of my ability, as demonstrated by the Wikipedia page (in acknowledgements), but still stands for minor technical improvement. For the organization of my project, I first created the classes for each class defined (Node, Graph, and Dijkstra), then I answered the questions as provided on schoology, and built the Dijkstra’s Algorithm based on that. For the algorithm, I created several helper methods and added in-doc comments for each part to explain a bit of the implementation. In the main method, I create an instance of Dijkstra and run the solve method. Lastly, I faced many challenges throughout interpreting the Dijkstra project, specifically with the creation of the solve() method, but was able to overcome them with help of Mr. Kuszmaul. Despite these challenges and obstacles, I have been able to create corresponding code to successfully perform Dijkstra’s Algorithm and meet the requirements of each aspect of the dictated methods.

FULFILLMENT OF SPECIFICATIONS: My java code successfully fulfills the requirements from the specification file with classes of Node, Graph, and Dijkstra, and with Node having only an identifier, and Graph having an instance where Arraylists representing a graph can be initialized. As requested, my Node class has one identifier and is used in Dijkstra to represent a Node. Graph holds an Arraylist of Arraylist of Arraylists to store the shortest distance of each node from each other. In order to solve this problem, I created three different arrays, truthValues, shortestD, and previousNodes. The truthValues initially holds an Arraylist of false values, that turn true once the shortest distance for the node at the that index (+1) has been found. shortestD is also an Arraylist that holds the shortest distance for the node at that index (+1). And, previousNodes is an Arraylist that holds the node used to get that shortest distance. For the home node, their index in previousNodes would hold a null value, while nodes directly connected to the home node would hold the previousNodes value of that home node. This method iterates through the ArrayLists in the given graph, initializes and then compares shortest distances. These shortest distances, when found, set the truthValues index to true, and sets the previousNodes index to the node used. Finally, all of the empty spaces in these methods are set to true and the previousNodes are set to the home node, as these are the nodes that have the shortest distance straight to the home node, meaning they are directly connected. Finally, the solve method returns the previousNodes Arraylist, and in the “SOLUTION” tag in the console, one can see the demonstration of Dijkstra’s Algorithm and the answer. Overall, this is how the specifications of the Logical Sentence Puzzle were met, along with the creation of classes and constructors with a few errors explained later.

ERRORS/AREAS FOR IMPROVEMENT: One error in my code, or area of improvement, is in the organization of the methods and helper methods. Right now, the solve method has multiple separate functions, whereas it should have been running multiple helper methods and stand as the larger overall method. In order to fix this, it requires some quick organization. Another error I may have not accounted for is if the Node is 0. I would most likely have an error if the Node given has an identifier that is at 0 or less than 0. This also applies to any non-number Node, which is currently not possible because of the Integer restriction on the Node identifier, and therefore my method forces any input of graph to all have number nodes above 1 that correspond to the graph indexes. However, there could’ve been a much better way to do this, and this is one place where my code may fall short. I would fix this by researching into how to create Dijkstra’s Algorithm with these restrictions, using my resources of Stack Overflow, Tutorial Point, Kuszmaul, and my peers Zage Strassberg-Phillips and Sabrina Martin.

OVERVIEW: First, the code creates an instance of Graph, and my code initializes Graph with a method inside graph, which initializes the graph Arraylist of Arraylists of Arraylists to the given data from the Wikipedia page. And, it creates a new node that the Wikipedia page uses, Node 1. Then, the code creates a new instance of Dijkstra, and initializes with a new node and the graph. By creating an instance of Dijsktra, the init() method runs, which initializes each of the items in each arraylist to their generic values and prints the result. Then, in the main menu, the code calls the instance of Dijkstra’s solve method. This method firsts runs setWithGraph() on the Arraylist where the home node is, found using the graph and the home node. Then, solve() calls a for loop with a limit of the size of the graph, and runs through each node Arraylist in the graph. For each node Arraylist, a method called check() is called, which iterates through each distance in the node Arraylist, and changes shortestD, previousNodes, and truthValues as needed. Finally, the homeNodes() are initialized, the remaining nodes with no previousNodes, and their truthValues are set to true and their previousNodes set to the given node. At last, all three Arraylists are printed, and the previousNodes, the result, is printed under the tag “SOLUTION”.
There was one major challenge I faced in the code,the creation of the solve() method. First, I had trouble understanding what the code’s purpose was and what the output was supposed to be. For this, I consulted Mr. Kuszmaul, who referenced the lecture he gave on the three columns used for Dijkstra’s Algorithm, and confirmed that I could use three Arraylists to represent those columns. After that, I became stuck on how to actually compare the distances. Initially, I created many helper methods, trying to iterate through the code too many times. After some thought and deliberation, I realized I only had to iterate twice to reach it’s value, and I could reference the two numbers (the index of the node Arraylist and then the index of the node referenced) to find that node in the three other Arraylists. Once I realized this, I was able to significantly simplify my code, and only use two methods. Then, once I found that I could easily access each value, out came to the hard part: what to compare. After experimenting many times with different numbers and ways of coming to each value, I was able to figure out that the distance must come from the homeNode to a certain node, and then from that node to the desired node. I got the concept of “distance” and I used a separate array (the home array) right before check() to find this distance. Once this realization was made, and after a bit of tinkering, I solved the algorithm! Overall, this was the worst struggles, and I’m glad I overcame it.

ACKNOWLEDGEMENTS: Thank you to https://pausd.schoology.com/assignment/1515989573/info (created by Kuszmaul), which provided me with the initial instructions and steps for Dijkstra’s Algorithm. Additionally, I would like to thank Zage Strassberg-Phillips for giving me encouragement to persist through my challenges, Mr. Kuszmaul for helping me understand the purpose and the return of Dijkstra’s Algorithm, and the Wikipedia Page https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#/media/File:Dijkstra_Animation.gif for providing me with the example to use in Java.
